\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}

\usepackage{graphicx}
\usepackage{paralist}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{hhline}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{multicol}
\usepackage{url}

\oddsidemargin 0mm
\evensidemargin 0mm
\textwidth 160mm
\textheight 200mm
\renewcommand\baselinestretch{1.0}

\pagestyle {plain}
\pagenumbering{arabic}

\newcounter{stepnum}

%% Comments

\usepackage{color}

\newif\ifcomments\commentstrue

\ifcomments
\newcommand{\authornote}[3]{\textcolor{#1}{[#3 ---#2]}}
\newcommand{\todo}[1]{\textcolor{red}{[TODO: #1]}}
\else
\newcommand{\authornote}[3]{}
\newcommand{\todo}[1]{}
\fi

\title{Assignment 4 Specification}
\author{SFWR ENG 2AA4}


\begin {document}

\maketitle
This Module Interface Specification (MIS) document contains modules, types and methods for implementing the Dots game. The spec utilizes the Model-View-Controller design pattern. 

The model creates and sets up the Dots Game board and its arrangement, as well as modifying the board's state. The view displays the Dots Game Board \& game messages to the user, and also receives the input from the user. The controller contains the logic and action of the Dots game, calling both the model and view to modify both the game board and display messages based on the game logic.

\newpage

\section* {Colour Type Module}

\subsection*{Module}

ColourT

\subsection* {Uses}

N/A

\subsection* {Syntax}

\subsubsection* {Exported Constants}

None

\subsubsection* {Exported Types}

Colours = \{R, G, B, Y, P\}\\

\noindent \textit{//R stands for Red, G for Green, B for Blue, Y for
  Yellow, P for Pink}

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
getRandomColour & ~ & ColourT & \\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

None

\subsubsection* {State Invariant}

None

\subsubsection* {Considerations}

\newpage

\subsubsection* {Access Routine Semantics}

getRandomColour():
\begin{itemize}
\item output: $out := $ a random type of ColourT
\item exception: None
\end{itemize}


\newpage

\section* {Dots ADT Module}

\subsection*{Template/Model Module}

Dots

\subsection* {Uses}

ColourT

\subsection* {Syntax}

\subsubsection* {Exported Types}

Dots = ?

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
Dots & $\mathbb{Z}$ & Dots & ~\\
\hline
matrix & ~ & Seq(Seq(ColourT)) & ~\\
\hline
n & ~ & $\mathbb{Z}$ & ~\\
\hline
getColour & $\mathbb{Z}$, $\mathbb{Z}$ & ColourT & ~\\
\hline
setColour & $\mathbb{Z}$, $\mathbb{Z}$ & ~ & ~\\
\hline
addRandomColour & $\mathbb{Z}$ & ~ & ~\\
\hline
setRandomColour & $\mathbb{Z}$, $\mathbb{Z}$ & ~ & ~\\
\hline
initializeDots & ~ & ~ & ~\\
\hline
isValidPath & Seq(Seq($\mathbb{Z}$)) & $\mathbb{B}$ & InvalidInputException\\
\hline
dropDots & ~ & ~ & ~\\
\hline
processDots & ~ & ~ & ~\\
\hline
hasValidCombo & ~ & $\mathbb{B}$ & ~\\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}

$n$: $\mathbb{Z}$\\
matrix: Seq of (Seq of ColourT)

\subsubsection* {State Invariant}

None

\subsubsection* {Assumptions}
The n state variable is to serve the purpose of being able to expand and/or shrink the board size and pieces. 

Another assumption that is made is that the isValidPath will produce an InvalidInputException.  In reality, an exception would stop the game in progress, thus the InvalidInputException is meant to only signify that the given input is invalid



\subsubsection* {Access Routine Semantics}

Dots($\mbox{num}$):
\begin{itemize}
\item transition: $\mbox{n, matrix} := \mbox{num}, \mbox{new Seq of (Seq of ColourT)} $
\item output: $out := \mathit{self}$
\item exception: None
\end{itemize}

\noindent matrix():
\begin{itemize}
\item output: $out := \mbox{matrix}$
\item exception: None
\end{itemize}

\noindent n():
\begin{itemize}
\item output: $out := n$
\item exception: None
\end{itemize}

\noindent getColour($i$, $j$):
\begin{itemize}
\item output: $out := \mbox{matrix}[i][j]$
\item exception: None
\end{itemize}

\noindent setColour($i$, $j$, $c$):
\begin{itemize}
\item transition: $\mbox{matrix}[i][j] := c$
\item exception: None
\end{itemize}

\noindent addRandomColour($i$):
\begin{itemize}
\item transition: $\mbox{matrix}[i][-1] :=  \mbox{ColourT.getRandomColour()}$  
\item exception: None
\end{itemize}

\noindent setRandomColour($i$, $j$):
\begin{itemize}
\item transition: $\mbox{matrix}[i][j] := \mbox{ColourT.getRandomColour()}$
\item exception: None
\end{itemize}

\noindent initializeDots():
\begin{itemize}
\item transition: $\forall i, j: \mbox{matrix}[i][j] := \mbox{ColourT.getRandomColour()} $
\item exception: None
\end{itemize}

\noindent isValidPath(in):
\begin{itemize}
\item out: $\forall i: \mbox{matrix}[\mbox{input}[i][0]] [\mbox{input}[i][1]] == \mbox{matrix}[\mbox{input}[i+1][0]] [\mbox{input}[i+1][1]] $
\item exception: $exc := (\exists i: (|\:\mbox{input}[i][0] - \mbox{input}[i+1][0]\:| > 1) \lor (|\:\mbox{input}[i][1] - \\ \mbox{input}[i+1][1] \:| > 1)) \implies \mbox{InvalidInputException}$
\end{itemize}

\noindent processDots():
\begin{itemize}
\item transition: $\mbox{matrix}[i][j] := $
\item exception: None
\end{itemize}

\noindent hasValidCombo():
\begin{itemize}
\item out: $\exists i, j: (\mbox{matrix}[i][j] == \mbox{matrix}[i][j+1] \lor \mbox{matrix}[i][j] == \mbox{matrix}[i+1][j]) $
\item exception: None
\end{itemize}
\bigskip
\subsection*{Local Functions}
processDots(): Drops dots based on existing null cells in each column (of the matrix).

\newpage

\section* {Dots View Module}

\subsection* {View Module}
DotsView

\subsection* {Uses}
N/A

\subsection* {Syntax}

\subsubsection* {Exported Types}
?

\subsubsection* {Exported Constants}
None

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | p{6cm} |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
startMenu & ~ & ~ & ~\\
\hline
printEnterNewInput & ~ & ~ & ~\\
\hline
displayScore & $\mathbb{Z}$ & ~ & ~\\
\hline
displayTarget & $\mathbb{Z}$ & ~ & ~\\
\hline
displayMovesLeft & $\mathbb{Z}$ & ~ & ~\\
\hline
printInvalidMove & ~ & ~ & ~\\
\hline
printReshuffled & ~ & ~ & ~ \\
\hline
printScoreReached & ~ & ~  & ~\\
\hline
printMovesOut & ~ & ~  & ~\\
\hline
renderDots & Seq(Seq(ColourT)) & ~  & ~\\
\hline
getInput & ~ & string & ~ \\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}
None

\subsubsection* {State Invariant}
None

\subsubsection* {Assumptions}
Since most of the routines in the View are just displaying print statements, the routines are ignored in the Access Routine Semantics. The purpose of each View routine is listed below: 

\begin{itemize}

\item startMenu(): display the Game Menu message
\item printEnterNewInput(): displays Enter New Input message
\item displayScore(n): display Score of $n$ 
\item displayTarget(n): display Target of $n$ 
\item displayMovesLeft(n): display Moves of $n$ 
\item printInvalidMove(): display Invalid Move message
\item printReshuffled(): displays Board Reshuffled message
\item printScoreReached(): displays Score Reached message
\item renderDots(board): display Game Board by: $\forall i, j: \mbox{display each }  \mbox{board}[i][j] $
\item getInput(): read and return input message

\end{itemize}

\subsubsection* {Access Routine Semantics}
N/A

\newpage

\section* {Dots Controller Module}

\subsection* {Controller Module}

DotsController

\subsection* {Syntax}

\subsection* {Uses}

N/A

\subsubsection* {Exported Constants}
None

\subsubsection* {Exported Types}
None

\subsubsection* {Exported Access Programs}

\begin{tabular}{| l | l | l | p{6cm} |}
\hline
\textbf{Routine name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
\hline
DotsController & Dots, DotsView & DotsController & \\
\hline
isValidInput & seq(string) & $\mathbb{B}$, $\mathbb{Z}$ & InvalidInputException\\
\hline
startGame & ~ & ~ & ~ \\
\hline
infiniteMode & ~ & ~ & ~ \\
\hline
targetMode & ~ & ~ & ~ \\
\hline
\end{tabular}

\subsection* {Semantics}

\subsubsection* {State Variables}
view: DotsView\\
model: Dots

\subsubsection* {State Invariant}
None

\subsubsection* {Assumptions}
One assumption that is made is that the isValidInput will produce an InvalidInputException. In reality, an exception would stop the game in progress, thus the InvalidInputException is meant to only signify that the given input is invalid.

Since the Game routines mainly consist of calling other view/model routines, they will not be described in the Access Routine Semantics.


\begin{itemize}
\item startGame(): Initiates the Game Board and menu messages
\item infiniteMode(): Game mode that tracks user's score 
\item targetMode(): Game mode that challenges user to reach target score in a limited amount of moves
\end{itemize}

\subsubsection* {Access Routine Semantics}

\noindent DotsController(dots, dotsview):
\begin{itemize}
\item transition: view, model := dots, dotsview 
\item out: $out := self$
\item exception: None
\end{itemize}

\noindent isValidInput(input, n):
\begin{itemize}
\item output: $out := (|\mbox{input}| >= 2) \land (\forall i: |\mbox{input}[i]| == 2 \land (\mbox{input}[i][0] < n \land \\ \mbox{input}[i][1] < n))$
\item exception: $exc := \lnot \mbox{(isValidInput(input,n))} \implies \mbox{InvalidInputException}$
\end{itemize}

\newpage

\section*{Critique of the Design}
The overall design of the MVC design pattern flows well with the design aspect of a game, as it enables information hiding for the Dots Model and DotsView from DotsController. DotsController does not have direct access in modifying the matrix and size of the board in the Dots Model. The design pattern also restricts modification of the messages displayed or the input received in DotsView. 

High cohesion is also present with this specification, as the DotsController is highly dependent on the behaviour of its model and view. The DotsController is the module that controls the logic of the Dots Model and the action of the DotsView. 

In addition, miminality was taken into account for this specification. For all modules, its access routines either does a State Transition or an Output, but never both. 

Generality is one area that is lacking in this specification, as there are no generic modules or interfaces implemented. While it's not a key design aspect for this project, generality can be improved by creating a generic module for the Dots Model. The model can accept any type (T) for it's 2D array matrix. We can further create a subclass/sub-model of the generic Dots class to implement it for ColourT types. 

Finally, consistency is used throughout this specification, ensuring uniform naming conventions and exception handling etc. 


\section*{Answer to Design Questions}

\begin{enumerate}
\item While all of the UML diagrams for these design patterns are very similar, they all have their own intended uses when utilizing them in Software projects. 

The purpose of the Proxy pattern is to have an interface as a means for a client to access an object, class etc. through that interface. However, this prevents the client from directly accessing that object/class.

The Adapter pattern is a pattern that connects two otherwise incompatible interfaces together by wrapping an existing class with the target interface. That way, the client gains functionality between both interfaces. This differs from the proxy because an Adapter provides access to another interface, while proxy provides access to the only interface created. 

The Strategy pattern is when we develop an interface that handles multiple implementations, enabling abstraction. The defining factor of the Strategy pattern is that the class behaviour (or implementation) can be selected/changed at runtime. The Strategy pattern is quite different compared to the other two, due to the runtime feature and that the interface deals with multiple implementations. 

\item Control Flow Diagram:
 
\end{enumerate}

\end {document}