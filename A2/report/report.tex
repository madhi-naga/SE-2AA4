\documentclass[12pt]{article}

\usepackage{graphicx}
\usepackage{paralist}
\usepackage{listings}
\usepackage{booktabs}

\usepackage{graphicx}
\usepackage{paralist}
\usepackage{listings}
\usepackage{booktabs}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
}

\oddsidemargin 0mm
\evensidemargin 0mm
\textwidth 160mm
\textheight 200mm

\pagestyle {plain}
\pagenumbering{arabic}

\newcounter{stepnum}

\title{Assignment 2 Solution}
\author{Madhi Nagarajan, nagarajm}
\date{\today}

\begin {document}

\maketitle

This purpose of this assignment is based on creating a program for that handles chemical elements
and has the ability to mathematically form molecules (MoleculeT), compounds (CompoundT), and balance chemical reactions (ReactionT). Testing and formatting of these classes were also done, utilizing pytest and flake8, to verify our personal code and our partner's code.

\section{Testing of the Original Program}
The test cases made for Test\_All were based on either reasonable or boundary value inputs. For the ReactionT test cases, they were based on various reactions from \url{https://www.nayuki.io/page/chemical-equation-balancer-javascript}. When testing my program, I received 16 (all) passes. However, I had 16 warnings relating to when using linalg and rcond when calculating the coefficients.

\section{Results of Testing Partner's Code}
When originally running pytest for my partner's code, it actually failed due to errors in ReactionT. When calling a function, he forgot to add self when calling \_\_elm\_in\_chem\_eq. He also forgot to declare variable 'a'.
\newline 
Once these errors were fixed, I ran pytest again. This time, the results showed 8 passes and 8 failures. When looking over the failed cases, most were related to checking whether a ElmSet/MolecSet were equivalent (in value) to each other. I realized that in my code, I add the \_\_eq\_\_ function in the Set class, thus assertions with '==' would automatically redirect these cases to the 'equals' function in Set. However, my partner did not use \_\_eq\_\_, thus '==' was checking whether the Sets were memory equivalent. \newline 
One thing to mention is that my test case selection was flawed for test\_Set\_to\_seq, as '==' checked if both Sets (in list format) were equivalent at each index. I did not realized this with my test cases for my own code. I rectified the error by converting the lists to the built-in python set datatype. \newline
In addition, one of the test cases for my partner's code failed when trying to remove (rm function) a value from a Set where it does not exist. The reason was that a ValueError occured, as his rm function raised that error. I actually realized that in my own code, I forgot to raise a ValueError exception when this happens. Instead, my code simply does not perform the rm operation for invalid elements in a Set. \newline
Once all these errors were fixed, I ran pytest again and it showed two failures, for test\_ReactionT\_get\_lhs\_coeff and for test\_ReactionT\_get\_rhs\_coeff. This was because my partner did not implement code for balancing coefficients in ReactionT. \newline \newline
I found this assignment to be more difficult to produce accurate and valid test cases, as there were alot of functions and classes to keep track of. Also due to the fact that it's not as a straightforward to evaluate whether two Sets are equal. 
\newline
The assignment specification was also designed with generality, opacity, and abstraction in mind. Since the final task is ReactionT, and requires all the other modules for it to function, it made sense to first tackle the simpler, general problems such as creating a molecule or combining molecules to make a compound.

\section{Critique of Given Design Specification}
Personally, I found the MIS formal specification for Assignment 2 made it straightforward to know exactly what parameters and the expected output should produce. However, I thought that when creating the program, it made it especially difficult to understand exactly what the required requirements and the objective of the program/certain classes. For example, I was confused on why we need two different modules (MoleculeT and CompoundT) to create a certain molecule/compound. After learning some background knowledge about molecules and compounds, it made more sense on why we need both. \newline This made me realize that not having adequate background knowledge on the topic you're developing a program for makes it very difficult especially with a formal specification. With A1 being less formal, it helped to explain and clear most doubts on exactly what the program is doing or its objective. The MIS specification was also very restrictive and not flexible for the most part. There were times where I wished I was able to implement a new function or class, especially relating to ReactionT, but would go against the requirements of the specification.
\newline
I found developing ReactionT was quite difficult, as the challenging part was creating the matricies for coefficient calculations. I had trouble trying to figure out a method to obtain all the elements and atoms for all compounds on both sides and creating coefficient equations for each element. Furthermore, there were alot of other functions and classes to consider and keep track of. I felt that ReactionT did not incorporate low coupling because it depended on the implementations of MoleculeT, CompoundT, and Set modules. Rather, high cohesion was more involved as the modules, especially MoleculeT and CompoundT, were similar as they both utilized the same interfaces (Set and Equality).  Minimality can be seen in the design of the specification when we utilized subclasses, ElmSet and MolecSet, for the Set class. This is so that ElmSet is specifically used for only sets of elements, while MolecSet is used for only sets of molecules. Consistency and essentiality is also present in this assignment as we utilized similar naming conventions and parameters for ADTs and its methods, and that all functions and classes are consistently used throughout the program. 

\section{Answers}

\begin{enumerate}[a)]

\item
With the natural language of A1, it was much easier to understand what the purpose was for each function or each file, thus it made it easier for me to implement. That being said, it does not give an exact specification on what parameters to take in or what the resulting output should exactly be. This means that the program depends on the developer's interpretation of the natural language specification. Thus, the end result may not maintain correctness it was expected to have. 
\newline
This is where a formal specification has its advantages. It clearly describes the parameters and output of the program. However one such feature it's lacking is that it is not very descriptive. I found that this assignment was somewhat difficult to understand the purpose of certain functions/code or how it can utilized by other classes. Furthermore, the specification can be somewhat restrictive of what the developer can do since it specifies how exactly the function/class should be designed.   

\item
To collect and convert strings to an object type, I would use the eval() function in python. This would parse parse the strings, in order to convert it into an object type. I would use a generic module, which its purpose is to collect a stack of strings. The module would convert the strings to ADT type like ElementT. 

\item
I would change the current ChemTypes class to a store a list for each enum, containing both it's atomic number and atomic mass (eg. H = [1.01, 1]). We can then have a constructor (get\_mass()) that returns an element's atomic mass. For MoleculeT, a mass constructor can be used again, but this time it multiplies the number of atoms with the atomic mass. For CompoundT, it would take the sum of all MoleculeT masses in its compound.

\item
Numpy provides the coefficients in real numbers. However the actual conventions in chemistry is commonly natural numbers, as its not possible to have fractions of real molecules. With the real number coefficients, it's quite simple to develop an algorithm that converts these fractions to whole numbers. We'd want to multiply the coefficients by the inverse of the lowest coefficient value, as characterized in \url{http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.1028.5627&rep=rep1&type=pdf}. 

\item
Static typing is when the variable's type is kow at compile time, where as dynamic typing is when we don't have to define the type before compiling; the compiler "trusts the programmer". Static typing's main advantage is that TypeError bugs are caught early on by the compiler. It also provides a sense of readability/safety especially with large amounts of code and classes because the programmer can easily tell what type of parameters/returns are being handled by a method. However, static typing can also be a burden for programmers, as it becomes difficult to type fast, clean code since you have to define types all the time.

\item
\begin{lstlisting}
pairs = [(x, y) for x in range(10) for y in range(10) 
		x % 2 == 1 and y % 2 == 1 and x < y]
\end{lstlisting}

\item
\begin{lstlisting}
def lengthlist(a):
  b = map(lambda x: 1, a)
  return sum(list(b))
\end{lstlisting}

\item
The interface of a module enables the module's clients to utilize the service offered by the module.The implementation of an interface provides the services offered by the module. Often the inteface acts like a blueprint of the module, which one can then implement on top of for the module to work and provide functionality. However, the interface cannot do anything by itself; it needs to be implemented.

\item
  \begin{enumerate}[i)]
\item Abstraction:
Interfaces enable abstraction because interfaces produce an abstract model or blueprint on the methods that implementations can utilize. Interfaces should be created with abstraction in mind. 
\item Anticipation of change:
Interfaces revolve around the idea of anticipation of change due to the fact that implementations may be changed during the development process or that newer implementations need to be made based on the same abstract model. 
\item Generality:
Generality is an approch to tackle more general problems first, then moving towards the complex ones. Interfaces should be created with generality in mind, so that it is flexible if several implementations are needed.
\item Modularity:
Modularity is when we divide a complex system into modules. Interfaces can take advantage of this idea, as interfaces can be utilized for several modules/implementations, helping to keep modules simple and seperated.  
\item Separation of concerns:
Seperation of concerns is similar to modularity, as its a principle that different concerns should be isolated. Seperation of concerns should be utilized with interfaces because while certain modules may have similar functionalities, it's important to keep them seperated. Interfaces help to do this, as modules can inherit from the same interfaces, but also extend on their own implementation.

\end{enumerate}

\end{enumerate}

\newpage

\lstset{language=Python, basicstyle=\tiny, breaklines=true, showspaces=false,
  showstringspaces=false, breakatwhitespace=true}
%\lstset{language=C,linewidth=.94\textwidth,xleftmargin=1.1cm}

\def\thesection{\Alph{section}}

\section{Code for ChemTypes.py}

\noindent \lstinputlisting{../src/ChemTypes.py}

\newpage

\section{Code for ChemEntity.py}

\noindent \lstinputlisting{../src/ChemEntity.py}

\newpage

\section{Code for Equality.py}

\noindent \lstinputlisting{../src/Equality.py}

\newpage

\section{Code for Set.py}

\noindent \lstinputlisting{../src/Set.py}

\newpage

\section{Code for ElmSet.py}

\noindent \lstinputlisting{../src/ElmSet.py}

\newpage

\section{Code for MolecSet.py}

\noindent \lstinputlisting{../src/MolecSet.py}

\newpage

\section{Code for CompoundT.py}

\noindent \lstinputlisting{../src/CompoundT.py}

\newpage

\section{Code for ReactionT.py}

\noindent \lstinputlisting{../src/ReactionT.py}

\newpage

\section{Code for test\_All.py}

\noindent \lstinputlisting{../src/test_All.py}

\newpage

\section{Code for Partner's Set.py}

\noindent \lstinputlisting{../partner/Set.py}

\newpage

\section{Code for Partner's MoleculeT.py}

\noindent \lstinputlisting{../partner/MoleculeT.py}

\newpage

\section{Code for Partner's CompoundT.py}

\noindent \lstinputlisting{../partner/CompoundT.py}

\newpage

\section{Code for Partner's ReactionT.py}

\noindent \lstinputlisting{../partner/ReactionT.py}

\end {document}
